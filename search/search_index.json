{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ModernStorage \u00b6 ModernStorage is a group of libraries that provide an abstraction layer over storage on Android to simplify its interactions by apps developers. ModernStorage is: Easy to use : ModernStorage focuses on API simplicity. Rather than calling four separate methods with the Android Framework API, you only need to call one. Opinionated : ModernStorage is written by the Android DevRel team in collaboration with the Android Storage team, taking in account all the feedback from the developer community to address common issues when dealing with storage on Android. Download \u00b6 ModernStorage is available on mavenCentral() . // For MediaStore interactions implementation ( \"com.google.modernstorage:modernstorage-mediastore:1.0.0-alpha02\" ) Quick start \u00b6 For MediaStore interactions, check out the sample app For non-media files on shared storage & SAF interactions, stay tuned for the upcoming filesystem package Is it ready? \u00b6 It's experimental! Our current version is 1.0.0-alpha02 . As it's an alpha release, we're expecting API breaking changes between releases. While it always seems risky to rely on an experimental library, we're enforcing storage best practises (including Scoped Storage), which developers aren't always aware of. We're looking for a stable release later this year (we don't have yet a precise date). We actively listen to your feedback to make ModernStorage the default library for storage interactions on Android. Contributions \u00b6 We're still at an early stage sharing the vision of ModernStorage and would love to have more feature requests and ideas proposed as issues. We would be glad to review pull requests, but keep in mind that we want to minimize expanding the API surface until we get more feedback from developers. Make sure to read the Contributing page first though. License \u00b6 Copyright 2021 Google LLC Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Home"},{"location":"#modernstorage","text":"ModernStorage is a group of libraries that provide an abstraction layer over storage on Android to simplify its interactions by apps developers. ModernStorage is: Easy to use : ModernStorage focuses on API simplicity. Rather than calling four separate methods with the Android Framework API, you only need to call one. Opinionated : ModernStorage is written by the Android DevRel team in collaboration with the Android Storage team, taking in account all the feedback from the developer community to address common issues when dealing with storage on Android.","title":"ModernStorage"},{"location":"#download","text":"ModernStorage is available on mavenCentral() . // For MediaStore interactions implementation ( \"com.google.modernstorage:modernstorage-mediastore:1.0.0-alpha02\" )","title":"Download"},{"location":"#quick-start","text":"For MediaStore interactions, check out the sample app For non-media files on shared storage & SAF interactions, stay tuned for the upcoming filesystem package","title":"Quick start"},{"location":"#is-it-ready","text":"It's experimental! Our current version is 1.0.0-alpha02 . As it's an alpha release, we're expecting API breaking changes between releases. While it always seems risky to rely on an experimental library, we're enforcing storage best practises (including Scoped Storage), which developers aren't always aware of. We're looking for a stable release later this year (we don't have yet a precise date). We actively listen to your feedback to make ModernStorage the default library for storage interactions on Android.","title":"Is it ready?"},{"location":"#contributions","text":"We're still at an early stage sharing the vision of ModernStorage and would love to have more feature requests and ideas proposed as issues. We would be glad to review pull requests, but keep in mind that we want to minimize expanding the API surface until we get more feedback from developers. Make sure to read the Contributing page first though.","title":"Contributions"},{"location":"#license","text":"Copyright 2021 Google LLC Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"filesystem/","text":"FileSystem \u00b6 modernstorage-filesystem is a library abstracting storage interactions when using the Storage Access Framework by wrapping document uris in Path . It allows using methods from java.nio.Files without having to learn another API like DocumentFile . java.nio is a non-blocking I/O API, available from API 26+ (Android Oreo). Popular libraries are already accepting Path as input such as Apache Commons, Google Guava and Okio. Info Not all java.nio.Files methods are supported yet . This guide highlights common supported ones. Add dependency to project \u00b6 modernstorage-filesystem is available on mavenCentral() . // build.gradle implementation ( \"com.google.modernstorage:modernstorage-filesystem:1.0.0-alpha02\" ) If your app minSdk is lower than API 26 , you need to override the filesystem minSdk requirement in your app's manifest: <!-- Don't forget to add the tools namespace (xmlns:tools) --> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:tools= \"http://schemas.android.com/tools\" package= \"com.sample.app\" > <!-- Override API 26 minSdk --> <uses-sdk tools:overrideLibrary= \"com.google.modernstorage.filesystem\" /> <!-- ... --> </manifest> Info modernstorage-filesystem is only available for API 26+ as Android adds support for java.nio.Files API from Oreo. For previous versions, you can request READ_EXTERNAL_STORAGE or WRITE_EXTERNAL_STORAGE permissions to access the shared storage. API reference \u00b6 modernstorage-filesystem API reference is available here . Initialize before usage \u00b6 To interact with FileSystem, you need to initialize it first: AndroidFileSystems . initialize ( context ) Select a file using SAF \u00b6 /** * We register first an ActivityResult handler for Intent.ACTION_OPEN_DOCUMENT * Read more about ActivityResult here: https://developer.android.com/training/basics/intents/result */ val actionOpenTextFile = registerForActivityResult ( OpenDocument ()) { uri -> if ( uri != null ) { // textPath is an instance of java.nio.file.Path val textPath = AndroidPaths . get ( documentUri ) } } actionOpenTextFile . launch ( arrayOf ( \"text/*\" )) Get a Path from a document Uri \u00b6 You can get a Path from a document Uri by using the method AndroidPaths.get : /** * documentUri refers to a Uri your app has received using SAF */ val path = AndroidPaths . get ( documentUri ) Get file size \u00b6 You can get the file size by using the method Files.size : val path = AndroidPaths . get ( documentUri ) val size = Files . size ( path ) Get InputStream \u00b6 You can get an InputStream of by using the method Files.newInputStream : val path = AndroidPaths . get ( documentUri ) val inputStream = Files . newInputStream ( path ) Read a text file \u00b6 You can read a text file by using the method Files.readAllLines : /** * documentUri refers to a Uri your app has received using SAF */ val path = AndroidPaths . get ( documentUri ) val content = Files . readAllLines ( path ). joinToString ( separator = \"\\n\" ) Get a bitmap from an image \u00b6 Modifying a file requires to scan it to make MediaStore aware of the file changes (size, modification date, etc.). To request a scan for a media URI, use the scanUri method: val path = AndroidPaths . get ( documentUri ) val inputStream = Files . newInputStream ( path ) val bitmap = BitmapFactory . decodeStream ( inputStream )","title":"FileSystem"},{"location":"filesystem/#filesystem","text":"modernstorage-filesystem is a library abstracting storage interactions when using the Storage Access Framework by wrapping document uris in Path . It allows using methods from java.nio.Files without having to learn another API like DocumentFile . java.nio is a non-blocking I/O API, available from API 26+ (Android Oreo). Popular libraries are already accepting Path as input such as Apache Commons, Google Guava and Okio. Info Not all java.nio.Files methods are supported yet . This guide highlights common supported ones.","title":"FileSystem"},{"location":"filesystem/#add-dependency-to-project","text":"modernstorage-filesystem is available on mavenCentral() . // build.gradle implementation ( \"com.google.modernstorage:modernstorage-filesystem:1.0.0-alpha02\" ) If your app minSdk is lower than API 26 , you need to override the filesystem minSdk requirement in your app's manifest: <!-- Don't forget to add the tools namespace (xmlns:tools) --> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:tools= \"http://schemas.android.com/tools\" package= \"com.sample.app\" > <!-- Override API 26 minSdk --> <uses-sdk tools:overrideLibrary= \"com.google.modernstorage.filesystem\" /> <!-- ... --> </manifest> Info modernstorage-filesystem is only available for API 26+ as Android adds support for java.nio.Files API from Oreo. For previous versions, you can request READ_EXTERNAL_STORAGE or WRITE_EXTERNAL_STORAGE permissions to access the shared storage.","title":"Add dependency to project"},{"location":"filesystem/#api-reference","text":"modernstorage-filesystem API reference is available here .","title":"API reference"},{"location":"filesystem/#initialize-before-usage","text":"To interact with FileSystem, you need to initialize it first: AndroidFileSystems . initialize ( context )","title":"Initialize before usage"},{"location":"filesystem/#select-a-file-using-saf","text":"/** * We register first an ActivityResult handler for Intent.ACTION_OPEN_DOCUMENT * Read more about ActivityResult here: https://developer.android.com/training/basics/intents/result */ val actionOpenTextFile = registerForActivityResult ( OpenDocument ()) { uri -> if ( uri != null ) { // textPath is an instance of java.nio.file.Path val textPath = AndroidPaths . get ( documentUri ) } } actionOpenTextFile . launch ( arrayOf ( \"text/*\" ))","title":"Select a file using SAF"},{"location":"filesystem/#get-a-path-from-a-document-uri","text":"You can get a Path from a document Uri by using the method AndroidPaths.get : /** * documentUri refers to a Uri your app has received using SAF */ val path = AndroidPaths . get ( documentUri )","title":"Get a Path from a document Uri"},{"location":"filesystem/#get-file-size","text":"You can get the file size by using the method Files.size : val path = AndroidPaths . get ( documentUri ) val size = Files . size ( path )","title":"Get file size"},{"location":"filesystem/#get-inputstream","text":"You can get an InputStream of by using the method Files.newInputStream : val path = AndroidPaths . get ( documentUri ) val inputStream = Files . newInputStream ( path )","title":"Get InputStream"},{"location":"filesystem/#read-a-text-file","text":"You can read a text file by using the method Files.readAllLines : /** * documentUri refers to a Uri your app has received using SAF */ val path = AndroidPaths . get ( documentUri ) val content = Files . readAllLines ( path ). joinToString ( separator = \"\\n\" )","title":"Read a text file"},{"location":"filesystem/#get-a-bitmap-from-an-image","text":"Modifying a file requires to scan it to make MediaStore aware of the file changes (size, modification date, etc.). To request a scan for a media URI, use the scanUri method: val path = AndroidPaths . get ( documentUri ) val inputStream = Files . newInputStream ( path ) val bitmap = BitmapFactory . decodeStream ( inputStream )","title":"Get a bitmap from an image"},{"location":"mediastore/","text":"MediaStore \u00b6 On Android, every files on the shared storage (files visible when using a file manager) are indexed by MediaStore , to allow apps to query them by type, date, size, etc. On API 29 (Android 10), Scoped Storage has been introduced, enabling a sandboxed view on the shared storage and the ability to add files without requesting permission. To read media files created by other apps, you need to request REQUEST_EXTERNAL_STORAGE and editing/deleting them require to ask user's consent . modernstorage-mediastore is a library abstracting these MediaStore API interactions on API 21+ (Android Lollipop). Add dependency to project \u00b6 modernstorage-mediastore is available on mavenCentral() . // build.gradle implementation ( \"com.google.modernstorage:modernstorage-mediastore:1.0.0-alpha02\" ) API reference \u00b6 modernstorage-mediastore API reference is available here . Initialize repository \u00b6 To interact with MediaStore, you need to initialize a MediaStoreRepository instance: val mediaStore by lazy { MediaStoreRepository ( context ) } Checking permissions \u00b6 Before adding, editing or deleting files, you should check if you have the permissions to do so. To avoid having a complex permission checking logic due to Scoped Storage changes, we have included helper methods in MediaStoreRepository : /** * If you only need to read your own entries in MediaStore */ if ( mediaStore . canReadOwnEntries ()) { println ( \"Read my image\" ) } /** * If you only need to read and write your own entries in MediaStore */ if ( mediaStore . canWriteOwnEntries ()) { println ( \"Edit my image\" ) } /** * If you need to read your own entries as well as the ones created by other apps in MediaStore */ if ( mediaStore . canReadSharedEntries ()) { println ( \"Read an image created by another app\" ) } /** * If you need to read and write your own entries as well as the ones created by other apps in * MediaStore */ if ( mediaStore . canWriteSharedEntries ()) { println ( \"Edit an image created by another app\" ) } Create media URI \u00b6 If you're using intents like ACTION_IMAGE_CAPTURE and want to personalize the MediaStore entry, use the createMediaUri method: val photoUri = mediaStore . createMediaUri ( filename = \"new-image.jpg\" , type = FileType . IMAGE , location = SharedPrimary ). getOrElse { reason -> println ( \"Creating Media URI failed: $ reason \" ) } Add media file \u00b6 You can add a media file by using the method addMediaFromStream . It will create a MediaStore URI, save the inputStream content in it, and scans the file before returning its Uri: /** * If you already have an InputStream */ val photoUri = mediaStore . addMediaFromStream ( filename = \"new-image.jpg\" , type = FileType . IMAGE , mimeType = \"image/jpg\" , inputStream = sample , location = SharedPrimary ). getOrElse { reason -> println ( \"Creating Media URI failed: $ reason \" ) } /** * Otherwise with a ByteArray */ val videoUri = mediaStore . addMediaFromStream ( filename = \"new-video.mp4\" , type = FileType . VIDEO , mimeType = \"video/mp4\" , inputStream = ByteArrayInputStream ( sampleByteArray ), location = SharedPrimary ). getOrElse { reason -> println ( \"Creating Media URI failed: $ reason \" ) } Scan media URI \u00b6 Modifying a file requires to scan it to make MediaStore aware of the file changes (size, modification date, etc.). To request a scan for a media URI, use the scanUri method: mediaStore . scanUri ( updatedPhotoUri , \"image/png\" ). getOrElse { reason -> println ( \"Scanning failed ( $ mediaUri ): $ reason \" ) } Get media URI details \u00b6 To get the details of a media URI (filename, size, file type, mime type), use the getResourceByUri method: val mediaDetails = mediaStore . getResourceByUri ( mediaUri ). getOrElse { reason -> println ( \"Fetching details failed ( $ mediaUri ): $ reason \" ) }","title":"MediaStore"},{"location":"mediastore/#mediastore","text":"On Android, every files on the shared storage (files visible when using a file manager) are indexed by MediaStore , to allow apps to query them by type, date, size, etc. On API 29 (Android 10), Scoped Storage has been introduced, enabling a sandboxed view on the shared storage and the ability to add files without requesting permission. To read media files created by other apps, you need to request REQUEST_EXTERNAL_STORAGE and editing/deleting them require to ask user's consent . modernstorage-mediastore is a library abstracting these MediaStore API interactions on API 21+ (Android Lollipop).","title":"MediaStore"},{"location":"mediastore/#add-dependency-to-project","text":"modernstorage-mediastore is available on mavenCentral() . // build.gradle implementation ( \"com.google.modernstorage:modernstorage-mediastore:1.0.0-alpha02\" )","title":"Add dependency to project"},{"location":"mediastore/#api-reference","text":"modernstorage-mediastore API reference is available here .","title":"API reference"},{"location":"mediastore/#initialize-repository","text":"To interact with MediaStore, you need to initialize a MediaStoreRepository instance: val mediaStore by lazy { MediaStoreRepository ( context ) }","title":"Initialize repository"},{"location":"mediastore/#checking-permissions","text":"Before adding, editing or deleting files, you should check if you have the permissions to do so. To avoid having a complex permission checking logic due to Scoped Storage changes, we have included helper methods in MediaStoreRepository : /** * If you only need to read your own entries in MediaStore */ if ( mediaStore . canReadOwnEntries ()) { println ( \"Read my image\" ) } /** * If you only need to read and write your own entries in MediaStore */ if ( mediaStore . canWriteOwnEntries ()) { println ( \"Edit my image\" ) } /** * If you need to read your own entries as well as the ones created by other apps in MediaStore */ if ( mediaStore . canReadSharedEntries ()) { println ( \"Read an image created by another app\" ) } /** * If you need to read and write your own entries as well as the ones created by other apps in * MediaStore */ if ( mediaStore . canWriteSharedEntries ()) { println ( \"Edit an image created by another app\" ) }","title":"Checking permissions"},{"location":"mediastore/#create-media-uri","text":"If you're using intents like ACTION_IMAGE_CAPTURE and want to personalize the MediaStore entry, use the createMediaUri method: val photoUri = mediaStore . createMediaUri ( filename = \"new-image.jpg\" , type = FileType . IMAGE , location = SharedPrimary ). getOrElse { reason -> println ( \"Creating Media URI failed: $ reason \" ) }","title":"Create media URI"},{"location":"mediastore/#add-media-file","text":"You can add a media file by using the method addMediaFromStream . It will create a MediaStore URI, save the inputStream content in it, and scans the file before returning its Uri: /** * If you already have an InputStream */ val photoUri = mediaStore . addMediaFromStream ( filename = \"new-image.jpg\" , type = FileType . IMAGE , mimeType = \"image/jpg\" , inputStream = sample , location = SharedPrimary ). getOrElse { reason -> println ( \"Creating Media URI failed: $ reason \" ) } /** * Otherwise with a ByteArray */ val videoUri = mediaStore . addMediaFromStream ( filename = \"new-video.mp4\" , type = FileType . VIDEO , mimeType = \"video/mp4\" , inputStream = ByteArrayInputStream ( sampleByteArray ), location = SharedPrimary ). getOrElse { reason -> println ( \"Creating Media URI failed: $ reason \" ) }","title":"Add media file"},{"location":"mediastore/#scan-media-uri","text":"Modifying a file requires to scan it to make MediaStore aware of the file changes (size, modification date, etc.). To request a scan for a media URI, use the scanUri method: mediaStore . scanUri ( updatedPhotoUri , \"image/png\" ). getOrElse { reason -> println ( \"Scanning failed ( $ mediaUri ): $ reason \" ) }","title":"Scan media URI"},{"location":"mediastore/#get-media-uri-details","text":"To get the details of a media URI (filename, size, file type, mime type), use the getResourceByUri method: val mediaDetails = mediaStore . getResourceByUri ( mediaUri ). getOrElse { reason -> println ( \"Fetching details failed ( $ mediaUri ): $ reason \" ) }","title":"Get media URI details"}]}